# ゲーム理論シミュレーションプロジェクト開発ガイドライン

## 1. プロジェクト概要

このプロジェクトは、ゲーム理論の概念（ナッシュの社会厚生、ムカデゲームなど）をシミュレーションするためのWebアプリケーションです。Laravel（PHP）をバックエンドに、JavaScript/TypeScriptをフロントエンドに使用しています。

## 2. サーバーサイド開発ガイドライン

### 2.1 App\Calculations クラス

App\Calculations ディレクトリには、ゲーム理論の計算を行うクラスが含まれています。現在、以下のクラスが実装されています：

#### 2.1.1 Nash 関連クラス

Nash 関連クラスは、ナッシュの社会厚生の計算を行います。計算処理とフォーマット処理を分離するために、以下のクラス構成になっています：

##### 2.1.1.1 Nash クラス

Nash クラスは、計算とフォーマットの橋渡しを行うファサードクラスです。主な特徴：

- `NashSimulator` と `NashFormatter` を内部で使用
- 主要メソッド：
  - `run()`: 計算のエントリーポイント（シミュレーションの実行とフォーマットを委譲）

##### 2.1.1.2 NashSimulator クラス

NashSimulator クラスは、ナッシュの社会厚生の計算ロジックを担当します。主な特徴：

- 分数計算に `Phospr\Fraction` ライブラリを使用
- 主要メソッド：
  - `run()`: シミュレーションを実行し、`NashSimulationResult` を返す
  - `calcGamma1X()`: ガンマ1のX座標を計算
  - `calcGamma2Y()`: ガンマ2のY座標を計算
  - `calcMidpoint()`: 中点を計算
  - `calcARho()`: a_rho値を計算

##### 2.1.1.3 NashFormatter クラス

NashFormatter クラスは、計算結果をフロントエンド用に整形します。主な特徴：

- 主要メソッド：
  - `format()`: `NashSimulationResult` をフロントエンド用の配列に変換
  - `getDisplayText()`: 表示用テキストを生成

##### 2.1.1.4 NashSimulationResult クラス

NashSimulationResult クラスは、シミュレーション結果を保持するDTOです。主な特徴：

- シミュレーション結果のすべての値を保持
- ゲッターメソッドを提供
- 各ゲッターメソッドには適切なPHPDocを記載（プロパティの説明と戻り値の型）

#### 2.1.2 Centipede クラス

Centipede クラスは、ムカデゲームのシミュレーションを行います。主な特徴：

- 複雑な数学的計算を `eval()` を使用して実行
- 主要メソッド：
  - `run()`: 複数パターンの計算を実行
  - `calculatePattern()`: 特定パターンの計算を実行
  - `unionCalculateData()`: 2つのプレイヤーのシミュレーション結果を合算
  - `calcCognitiveUnitValue()`: 認知単位の値を計算
  - `makeCognitiveUnitLatexText()`: LaTeX形式のテキストを生成
  - `makeChartData()`: チャート表示用データを生成

**注意**: 現在、Centipedeクラスは計算ロジックと表示ロジックが混在しています。将来的には、Nashクラスと同様に、計算処理（CentipedeSimulator）とフォーマット処理（CentipedeFormatter）に分離し、DTOを使用したリファクタリングを行う予定です。これにより、コードの保守性と拡張性が向上します。

### 2.2 分数計算の実装

計算クラスでは、精度を保つために分数計算を多用しています：

- `Phospr\Fraction` ライブラリを使用して分数を表現
- 分数の加減乗除は、対応するメソッド（`add()`, `subtract()`, `multiply()`, `divide()`）を使用
- 分数から浮動小数点数への変換は `toFloat()` メソッドを使用
- 分子と分母の取得には `getNumerator()` と `getDenominator()` メソッドを使用

### 2.3 PHPユニットテスト

PHPのユニットテストは、以下の方針で実装しています：

- `tests/Unit` ディレクトリにテストクラスを配置
- 計算クラスのテスト（例：`NashTest`, `CentipedeTest`）では：
  - privateメソッドのテストには `ReflectionClass` を使用
  - 複数のテストケースをデータプロバイダーで提供
  - 分数の計算結果は分子と分母の両方を検証
- リクエストバリデーションのテスト（例：`CalculateNashRequestTest`, `CalculateCentipedeRequestTest`）では：
  - `authorize()` メソッドのテスト
  - バリデーションルールの存在と内容の検証
  - 有効なデータと無効なデータの両方でのバリデーション検証
  - カスタムバリデーションルール（`FractionMax`, `Coordinate`など）のテスト
- ユニットテストを作成する時は、テスト対象クラスの1メソッドに対してユニットテストもメソッドを1件以上作成すること。1つのユニットテストメソッド内で複数のメソッドを検証しない。

### 2.4 DTOクラスのPHPDoc

DTOクラスのメソッドには、以下の方針でPHPDocを記載します：

- すべてのゲッターメソッドには適切なPHPDocを記載
- PHPDocには以下の情報を含める：
  - メソッドの説明（例：「alpha_xを取得する」）
  - 戻り値の型（例：「@return Fraction」）
- 複雑なDTOの場合は、プロパティの意味や使用方法についても説明を追加

### 2.5 配列型のPHPDoc

配列型をPHPDocに記載する際は、以下の方針に従います：

- 単に `array` と記載するのではなく、最低でも `array{key: mixed}` の形式で配列の構造を明示する
- 配列の要素の型が明確な場合は、`array{key: string, count: int}` のように具体的な型を指定する
- 連想配列でない場合は、`array<int, string>` のように記載する
- これにより、コードの可読性が向上し、型の不一致によるエラーを防止できる

## 3. フロントエンド開発ガイドライン

### 3.1 TypeScriptへの移行

現在、JavaScriptからTypeScriptへの移行を進めています：

- 新規コードはTypeScriptで記述
- 既存のJavaScriptコードは段階的にTypeScriptに移行中
- `tsconfig.json` で型チェックの設定を管理

#### 3.1.1 TypeScript実装例（nash.ts）

- 型定義を使用した関数宣言（例：`function reset(): void`）
- ES6モジュールインポート構文の使用
- イベントハンドラの実装

#### 3.1.2 JavaScript実装例（centipede.js）

- CommonJSスタイルの `require()` を使用したモジュールインポート
- jQueryを使用したDOM操作とイベントハンドリング
- ブラウザ検出とチャートダウンロード機能

### 3.2 reactへの移行

- 現在、Reactへの移行は進行中です。新規コンポーネントはReactで実装
- 既存のJavaScriptコードは段階的にReactコンポーネントに置き換え中
- jQueryの使用は最小限に抑え、Reactの状態管理を活用
- jQueryで書かれたコードは、段階的にReactのライフサイクルメソッドに置き換え

### 3.3 フロントエンド共通ガイドライン

- KaTeXライブラリを使用して数式を表示
- チャート表示には適切なライブラリを使用
- フォーム入力値のリセット機能を実装
- 計算中はスピナーを表示

## 4. 開発プロセス

### 4.1 新機能の追加

1. サーバーサイドの計算クラスを `App\Calculations` に実装
2. 対応するユニットテストを `tests/Unit/Calculations` に実装
3. リクエストバリデーションクラスを作成し、テストを実装
4. フロントエンドのTypeScriptコードを実装

### 4.2 既存機能の修正

1. 該当するテストを確認または追加
2. サーバーサイドコードを修正
3. フロントエンドコードを修正
4. テストを実行して変更を検証

## 5. junieからの提案書について

- junieに提案書を作成してもらった際には、 `docs/junie/` 以下に保存します
- junieにコード修正依頼を行う時、この提案書に沿って対応を依頼する場合があります

## 6. 注意事項

- 分数計算の実装は複雑なため、コメントを詳細に記述し、テストで十分に検証してください
- 数学的な計算式は、可能な限り定数として定義し、コメントで説明を追加してください
- JavaScriptからTypeScriptへの移行は慎重に行い、既存の機能を損なわないようにしてください
- `eval()` の使用は必要最小限に抑え、入力値のバリデーションを徹底してください

## 7. 不明確な点

- 分数計算の一部で、計算式が複雑になっている箇所があります。これらの計算式の数学的背景や意図については、必要に応じて専門家に確認することをお勧めします。
- Centipedeクラスの計算式（ODD_NU, EVEN_NU など）の詳細な意味や導出過程は、ゲーム理論の専門知識が必要な場合があります。
